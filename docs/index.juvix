module index;

--8<-- [start:hash]
module Hash;
  import Stdlib.Prelude open;
  import Stdlib.Data.Nat.Ord open;

  {-# unroll: 30 #-}
  terminating
  power' (acc a b : Nat) : Nat :=
    let
      acc' : Nat := if (mod b 2 == 0) acc (acc * a);
    in if (b == 0) acc (power' acc' (a * a) (div b 2));

  power : Nat â†’ Nat := power' 1 2;

  hash' : Nat -> Nat -> Nat
    | (suc n@(suc (suc m))) x :=
      if
        (x < power n)
        (hash' n x)
        (mod (div (x * x) (power m)) (power 6))
    | _ x := x * x;

  hash : Nat -> Nat := hash' 16;

  -- result: 3
  main : Nat := hash 1367;
end;
--8<-- [end:hash]

module IntentExample;
  
  import Simulator open;
  import Simulator.Resource open using {mkResource as mkResource'};
  import Apps.TwoPartyExchange.Asset open;

  import Data.Map as Map;
  open Map using {Map};

  import Stdlib.Prelude open;
  import Stdlib.Data.Int.Ord open;

  --- Definitions related to Alice's intent
  module AliceIntent;
    
    logicFunction : LogicFunction
      | kind tx :=
        let
          {- check if the resource associated to this logic function is among
                                      the created (output) resources. Then check if alice's intent is satisfied. -}
          createdRs : List Resource := createdResources tx;
          createdHashes : List LogicHash :=
            map Resource.logicHash createdRs;
        in isCreated kind
          || (quantityOfDenom Dolphin.denomination createdRs == 1
            && quantityOfDenom A.denomination createdRs == 1)
          || quantityOfDenom Dolphin.denomination createdRs == 1
          && quantityOfDenom B.denomination createdRs == 2;

    --- This will be computed from the logic function
    logicHash : LogicHash := 1;

    staticData : ByteString := 3 :: nil;

    denomination : Denomination := 1 :: staticData;

    mkResource (n : Int) : Resource :=
      mkResource'
        (logicHash := logicHash;
        staticData := staticData;
        dynamicData := nil;
        quantity := n);
  end;

  --8<-- [start:intent]
  module Alice;
    -- Alice is willing to exchange either 2 B or 1 A for 1 Dolphin.
    partialTransaction : PartialTx :=
      mkPartialTx
        (consumedPair := A.mkResource 1, B.mkResource 2;
        createdPair := AliceIntent.mkResource 1, dummyResource);
  end;

  module Bob;
    partialTransaction : PartialTx :=
      mkPartialTx
        (consumedPair := Dolphin.mkResource 1, dummyResource;

        createdPair := A.mkResource 1, dummyResource);
  end;

  module Solver;
    partialTransaction : PartialTx :=
      mkPartialTx
        (consumedPair := AliceIntent.mkResource 1, dummyResource;
        createdPair := Dolphin.mkResource 1, B.mkResource 2);
  end;
  --8<-- [end:intent]

  --8<-- [start:logics]
  logicFunctions : Map LogicHash LogicFunction :=
    mkLogicFunctionMap
      ((AliceIntent.logicHash, AliceIntent.logicFunction) :: nil);
--8<-- [end:logics]
end;
